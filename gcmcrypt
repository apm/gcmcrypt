#!/usr/bin/env python

import argparse
import binascii
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers import (
    Cipher, algorithms, modes)
import os
import sys


def read_key(noprompt=False):
    key = b''
    if not noprompt:
        os.write(2, b'Enter key or passphrase, ending with EOF: ')
    for l in sys.stdin:
        l = l.rstrip()
        if sys.version_info[0] > 2:  # bytes for python 3
            l = l.encode('latin-1')
        key += l

    return key


def encrypt(key, f):
    iv = os.urandom(12)
    # Construct an AES-GCM Cipher object with the given key and a
    # randomly generated IV.
    encryptor = Cipher(
        algorithms.AES(key),
        modes.GCM(iv),
        backend=default_backend()).encryptor()

    # associated_data will be authenticated but not encrypted,
    # it must also be passed in on decryption.
    encryptor.authenticate_additional_data(b'')

    os.write(1, iv)  # Write to stdout on 1 for Python 2, 3 portability
    while True:
        line = f.read(65536)
        if len(line) == 0:  # Finished
            os.write(1, encryptor.finalize() + encryptor.tag)
            break
        os.write(1, encryptor.update(line))


def decrypt(key, f):
    # Check file has enough data to be encrypted
    f.seek(0, 2)
    assert f.tell() >= 28, 'File too small to have been encrypted by gcmcrypt'
    # Back to the start
    f.seek(0, 0)
    iv = f.read(12)
    # Grab the tag from the end of the file
    f.seek(-16, 2)
    size = f.tell() - 12  # Size of ciphertext
    tag = f.read(16)
    assert len(tag) == 16
    f.seek(12, 0)  # Back to start of ciphertext
    # Cipher object with tag, and empty associated data
    decryptor = Cipher(
        algorithms.AES(key),
        modes.GCM(iv, tag),
        backend=default_backend()).decryptor()
    decryptor.authenticate_additional_data(b'')

    while True:
        if size > 0:
            line = f.read(min(65536, size))
            size -= len(line)
        else:
            line = b''
        if len(line) == 0:  # Finished
            os.write(1, decryptor.finalize())
            break
        os.write(1, decryptor.update(line))

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--decrypt', help='Decrypt rather then encrypt',
                        action='store_true')
    parser.add_argument('-k', '--key', help='Hex key from stdin',
                        action='store_true')
    parser.add_argument('-n', '--noprompt',
                        help='Do not prompt for key or passphrase on stderr',
                        action='store_true')
    parser.add_argument('-p', '--passphrase', help='Passphrase from stdin',
                        action='store_true')
    parser.add_argument('file', help="File to encrypt or decrypt")
    args = parser.parse_args()
    if args.key == args.passphrase:
        raise ValueError('Must specify one of -k or -p')
    key = read_key(noprompt=args.noprompt)
    if args.passphrase:
        sha256 = hashes.Hash(hashes.SHA256(), backend=default_backend())
        sha256.update(key)
        key = sha256.finalize()
    else:
        key = binascii.unhexlify(key)
        assert len(key) == 32, 'Key must be 64 hex digits, got {l}'.format(
            l=len(key) * 2)
    with open(args.file, 'rb') as fd:
        if args.decrypt:
            decrypt(key, fd)
        else:
            encrypt(key, fd)

    exit(0)
